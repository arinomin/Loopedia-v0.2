import { useState, useEffect } from "react";
import { Link, useLocation } from "wouter";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { Switch } from "@/components/ui/switch";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { ParameterInput } from "@/components/ui/parameter-input";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { EFFECTS, TRACK_A_EFFECTS, getEffectParameters, getEffectOptions } from "@/lib/effects";
import {
  EffectType,
  EffectPosition,
  ExtendedEffectPosition,
  SwitchMode,
  InsertType,
} from "@shared/schema";
import { ChevronDown } from "lucide-react";
import { LoginModal } from "@/components/auth/login-modal";
import { ArrowLeft } from "lucide-react"; // アイコンをインポート

interface EffectConfig {
  position: EffectPosition | ExtendedEffectPosition;
  effectType: string;
  sw: boolean;
  swMode: SwitchMode;
  insert: InsertType;
  parameters: Record<string, any>;
}

const INITIAL_EFFECT_CONFIG: EffectConfig = {
  position: "A",
  effectType: "LPF",
  sw: true, // 初期値をONに変更
  swMode: "TOGGLE",
  insert: "ALL",
  parameters: {},
};

export default function PresetCreate() {
  const [_, navigate] = useLocation();
  const { toast } = useToast();

  // 編集用のプリセットデータが渡されているか確認
  const locationState = window.history.state?.state?.preset;
  const sourcePreset = locationState || null;

  // Fetch current user
  const { data: currentUser } = useQuery({
    queryKey: ["/api/auth/me"],
  });

  // ログインモーダルの状態
  const [isLoginModalOpen, setIsLoginModalOpen] = useState(false);

  // State for preset data
  const [presetName, setPresetName] = useState(
    sourcePreset ? `${sourcePreset.name} (コピー)` : "",
  );
  const [presetTags, setPresetTags] = useState(
    sourcePreset
      ? sourcePreset.tags
          .map((tag: { id: number; name: string }) => tag.name)
          .join(", ")
      : "",
  );
  const [fxType, setFxType] = useState<EffectType>(
    sourcePreset ? sourcePreset.type : "INPUT_FX",
  );
  const [currentTab, setCurrentTab] = useState<EffectPosition>("A");
  
  // INPUT/TRACKタブ管理用
  const [fxGroupTab, setFxGroupTab] = useState<"input" | "track">("input");

  // 初期エフェクト設定
  const initialEffects: Record<EffectPosition, EffectConfig> = {
    A: { ...INITIAL_EFFECT_CONFIG, position: "A", effectType: "LPF" },
    B: { ...INITIAL_EFFECT_CONFIG, position: "B", effectType: "LPF" },
    C: { ...INITIAL_EFFECT_CONFIG, position: "C", effectType: "LPF" },
    D: { ...INITIAL_EFFECT_CONFIG, position: "D", effectType: "LPF" },
  };
  
  // INPUT_TRACK_FX用の初期エフェクト設定
  const initialInputEffects: Record<EffectPosition, EffectConfig> = {
    A: { ...INITIAL_EFFECT_CONFIG, position: "INPUT_A", effectType: "LPF" },
    B: { ...INITIAL_EFFECT_CONFIG, position: "INPUT_B", effectType: "LPF" },
    C: { ...INITIAL_EFFECT_CONFIG, position: "INPUT_C", effectType: "LPF" },
    D: { ...INITIAL_EFFECT_CONFIG, position: "INPUT_D", effectType: "LPF" },
  };
  
  const initialTrackEffects: Record<EffectPosition, EffectConfig> = {
    A: { ...INITIAL_EFFECT_CONFIG, position: "TRACK_A", effectType: "LPF" },
    B: { ...INITIAL_EFFECT_CONFIG, position: "TRACK_B", effectType: "LPF" },
    C: { ...INITIAL_EFFECT_CONFIG, position: "TRACK_C", effectType: "LPF" },
    D: { ...INITIAL_EFFECT_CONFIG, position: "TRACK_D", effectType: "LPF" },
  };

  // INPUTエフェクト設定
  const [inputEffects, setInputEffects] = useState<Record<EffectPosition, EffectConfig>>(initialInputEffects);
  
  // TRACKエフェクト設定
  const [trackEffects, setTrackEffects] = useState<Record<EffectPosition, EffectConfig>>(initialTrackEffects);

  // コピー元のプリセットからエフェクト設定を取得
  const [effects, setEffects] = useState<Record<EffectPosition, EffectConfig>>(
    () => {
      if (!sourcePreset || !sourcePreset.effects) {
        return initialEffects;
      }

      // コピー元のエフェクトをマップに変換
      const sourceEffects = { ...initialEffects };

      sourcePreset.effects.forEach((effect: any) => {
        if (effect.position && ["A", "B", "C", "D"].includes(effect.position)) {
          // パラメータがJSON文字列の場合はパースする
          let parsedParameters = {};

          try {
            // 文字列の場合はパース、オブジェクトの場合はそのまま使用
            if (effect.parameters) {
              if (typeof effect.parameters === "string") {
                parsedParameters = JSON.parse(effect.parameters);
              } else {
                parsedParameters = effect.parameters;
              }
            }
          } catch (err) {
            console.error("パラメータのパースに失敗:", err);
          }

          sourceEffects[effect.position as EffectPosition] = {
            position: effect.position as EffectPosition,
            effectType: effect.effectType || "LPF",
            sw: effect.sw !== undefined ? effect.sw : true, // 初期値をONに変更
            swMode: effect.swMode || "TOGGLE",
            insert: effect.insert || "ALL",
            parameters: parsedParameters,
          };
        }
      });

      return sourceEffects;
    },
  );

  // 初期化時にすべてのエフェクトのパラメータを設定
  useEffect(() => {
    const initializedEffects = { ...effects };

    Object.keys(initializedEffects).forEach((position) => {
      const effect = initializedEffects[position as EffectPosition];
      const parameters = getEffectParameters(effect.effectType);
      const defaultParams: Record<string, any> = {};

      // Set default values for parameters
      parameters.forEach((param) => {
        defaultParams[param.name] = param.defaultValue;
      });

      // Merge with any existing parameters
      initializedEffects[position as EffectPosition].parameters = {
        ...defaultParams,
        ...effect.parameters,
      };
    });

    setEffects(initializedEffects);
  }, []);

  // Create preset mutation
  const createPresetMutation = useMutation({
    mutationFn: (data: any) => {
      return apiRequest("/api/presets", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(data),
      });
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/presets"] });
    },
    onError: (error) => {
      console.error("Create preset error:", error);
    },
  });

  const handleTabChange = (value: string) => {
    setCurrentTab(value as EffectPosition);
  };

  // 通常のエフェクト更新関数
  const updateEffect = (
    position: EffectPosition,
    updates: Partial<EffectConfig>,
  ) => {
    setEffects((prev) => ({
      ...prev,
      [position]: {
        ...prev[position],
        ...updates,
      },
    }));
  };
  
  // INPUTエフェクト更新関数
  const updateInputEffect = (
    position: EffectPosition,
    updates: Partial<EffectConfig>,
  ) => {
    setInputEffects((prev) => ({
      ...prev,
      [position]: {
        ...prev[position],
        ...updates,
      },
    }));
  };
  
  // TRACKエフェクト更新関数
  const updateTrackEffect = (
    position: EffectPosition,
    updates: Partial<EffectConfig>,
  ) => {
    setTrackEffects((prev) => ({
      ...prev,
      [position]: {
        ...prev[position],
        ...updates,
      },
    }));
  };

  const handleEffectTypeChange = (value: string) => {
    const effect = effects[currentTab];

    if (value === effect.effectType) return;

    const parameters = getEffectParameters(value);
    const defaultParams: Record<string, any> = {};
    parameters.forEach((param) => {
      defaultParams[param.name] = param.defaultValue;
    });

    updateEffect(currentTab, {
      effectType: value,
      parameters: defaultParams,
    });
  };

  // プリセットのバリデーション
  const validatePreset = () => {
    if (!presetName.trim()) {
      toast({
        title: "エラー",
        description: "プリセット名を入力してください",
        variant: "destructive",
      });
      return false;
    }

    return true;
  };

  // ログイン成功後にプリセットを保存する
  const savePresetAfterLogin = () => {
    if (!validatePreset()) return;

    // Process tags
    const tags = presetTags
      .split(",")
      .map((tag: string) => tag.trim())
      .filter((tag: string) => tag !== "");

    // Prepare effects data
    let configuredEffects;
    
    if (fxType === "INPUT_TRACK_FX") {
      // INPUT側のエフェクト
      const inputConfiguredEffects = Object.values(inputEffects).filter(
        (effect) => effect.effectType !== "none",
      );
      
      // TRACK側のエフェクト
      const trackConfiguredEffects = Object.values(trackEffects).filter(
        (effect) => effect.effectType !== "none",
      );
      
      // 両方を結合
      configuredEffects = [...inputConfiguredEffects, ...trackConfiguredEffects];
    } else {
      // 通常のエフェクト
      configuredEffects = Object.values(effects).filter(
        (effect) => effect.effectType !== "none",
      );
    }

    const effectsData = configuredEffects.map((effect) => {
      let processedParameters;
      
      try {
        // パラメータの処理を詳細なログとともに実行
        console.log(`処理前のパラメータ (${effect.position}):`, {
          type: typeof effect.parameters,
          value: effect.parameters
        });
        
        // パラメータの完全性を確保
        // すでにJSON文字列の場合はそのまま、オブジェクトならJSON文字列に変換
        if (typeof effect.parameters === 'string') {
          // 文字列が有効なJSONか確認し、無効ならオブジェクトに変換して再度文字列化
          const parsedParams = JSON.parse(effect.parameters);
          // パース結果を確認
          console.log(`パラメータ文字列のパース結果 (${effect.position}):`, parsedParams);
          processedParameters = JSON.stringify(parsedParams);
        } else {
          // オブジェクトの場合はそのままJSON文字列化
          if (effect.parameters === null || effect.parameters === undefined) {
            console.warn(`パラメータがnullまたはundefined (${effect.position})`);
            processedParameters = "{}";
          } else {
            processedParameters = JSON.stringify(effect.parameters);
          }
        }
        
        console.log(`処理後のパラメータ (${effect.position}):`, processedParameters);
      } catch (e) {
        console.error("パラメータ処理エラー:", {
          position: effect.position,
          parameters: effect.parameters,
          error: e
        });
        // エラー時のフォールバック
        processedParameters = "{}";
      }
      
      return {
        ...effect,
        parameters: processedParameters,
      };
    });

    try {
      createPresetMutation.mutate({
        name: presetName,
        type: fxType,
        effects: effectsData,
        tags,
      }, {
        onSuccess: () => {
          toast({
            title: "プリセット保存完了",
            description: `プリセット "${presetName}" を保存しました`,
            variant: "default",
          });
          navigate("/");
        },
        onError: (error: any) => {
          console.error("プリセット保存エラー:", error);
          toast({
            title: "エラー",
            description: "プリセットの保存に失敗しました",
            variant: "destructive",
          });
        }
      });
    } catch (error) {
      console.error("プリセット保存エラー:", error);
      toast({
        title: "エラー",
        description: "プリセットの保存に失敗しました",
        variant: "destructive",
      });
    }
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    // 未ログインの場合はログインモーダルを表示
    if (!currentUser) {
      // 入力内容を検証
      if (validatePreset()) {
        setIsLoginModalOpen(true);
      }
      return;
    }

    // ログイン済みの場合はそのまま保存
    savePresetAfterLogin();
  };

  return (
    <div className="max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8">
      {/* ログインモーダル */}
      <LoginModal
        isOpen={isLoginModalOpen}
        onClose={() => setIsLoginModalOpen(false)}
        onLoginSuccess={savePresetAfterLogin}
        title="ログインが必要です"
        description="プリセットを保存するにはログインまたは新規登録が必要です。"
      />

      <div className="mb-6">
        <Link
          href="/"
          className="inline-flex items-center text-sm text-muted-foreground hover:text-primary"
        >
          <ArrowLeft className="h-4 w-4 mr-1" />
          戻る
        </Link>
      </div>

      <Card>
        <CardHeader>
          <CardTitle className="text-2xl font-semibold">
            プリセット作成
          </CardTitle>
          <CardDescription>
            RC-505mk2用のプリセットを作成します
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit}>
            <div className="grid grid-cols-1 gap-6 sm:grid-cols-6">
              <div className="sm:col-span-6">
                <Label htmlFor="preset-name">プリセット名</Label>
                <div className="mt-1">
                  <Input
                    id="preset-name"
                    value={presetName}
                    onChange={(e) => setPresetName(e.target.value)}
                  />
                </div>
              </div>

              <div className="sm:col-span-4">
                <Label htmlFor="preset-tags">タグ（カンマ区切り）</Label>
                <div className="mt-1">
                  <Input
                    id="preset-tags"
                    placeholder="例: ボーカル, ハーモニー, ライブ"
                    value={presetTags}
                    onChange={(e) => setPresetTags(e.target.value)}
                  />
                </div>
              </div>

              <div className="sm:col-span-6">
                <Label>FXタイプ</Label>
                <div className="mt-1">
                  <RadioGroup
                    value={fxType}
                    onValueChange={(value) => {
                      const newFxType = value as EffectType;
                      setFxType(newFxType);
                    }}
                    className="flex space-x-6 flex-wrap"
                  >
                    <div className="flex items-center space-x-2 mr-4 mb-2">
                      <RadioGroupItem value="INPUT_FX" id="input-fx" />
                      <Label htmlFor="input-fx">INPUT FX</Label>
                    </div>
                    <div className="flex items-center space-x-2 mr-4 mb-2">
                      <RadioGroupItem value="TRACK_FX" id="track-fx" />
                      <Label htmlFor="track-fx">TRACK FX</Label>
                    </div>
                    <div className="flex items-center space-x-2 mb-2">
                      <RadioGroupItem value="INPUT_TRACK_FX" id="input-track-fx" />
                      <Label htmlFor="input-track-fx">INPUT FX & TRACK FX</Label>
                    </div>
                  </RadioGroup>
                </div>
              </div>
            </div>

            {/* Effect Tabs */}
            <div className="mt-8">
              {fxType === "INPUT_TRACK_FX" ? (
                <div>
                  <Tabs defaultValue="input" className="w-full" onValueChange={(value) => setFxGroupTab(value as "input" | "track")}>
                    <TabsList className="w-full sm:w-auto mb-4">
                      <TabsTrigger value="input">INPUT FX</TabsTrigger>
                      <TabsTrigger value="track">TRACK FX</TabsTrigger>
                    </TabsList>
                    
                    <TabsContent value="input">
                      <div className="mb-2 text-sm text-muted-foreground">
                        INPUT側のエフェクト設定
                      </div>
                      <Tabs value={currentTab} onValueChange={handleTabChange}>
                        <TabsList className="w-full sm:w-auto">
                          <TabsTrigger value="A">FX A</TabsTrigger>
                          <TabsTrigger value="B">FX B</TabsTrigger>
                          <TabsTrigger value="C">FX C</TabsTrigger>
                          <TabsTrigger value="D">FX D</TabsTrigger>
                        </TabsList>

                        {["A", "B", "C", "D"].map((position) => (
                          <TabsContent key={position} value={position} className="mt-4">
                            <Collapsible className="bg-muted p-4 rounded-md mb-6">
                              <CollapsibleTrigger className="flex items-center justify-between w-full group">
                                <h4 className="text-md font-medium">Effect Control (INPUT)</h4>
                                <ChevronDown className="h-6 w-6 transition-transform duration-200 text-primary group-data-[state=open]:rotate-180" />
                              </CollapsibleTrigger>
                              <CollapsibleContent className="mt-4">
                                <div className="grid grid-cols-1 sm:grid-cols-3 gap-6">
                                  <div>
                                    <Label className="mb-2">SW</Label>
                                    <div className="flex items-center">
                                      <Switch
                                        checked={inputEffects[position as EffectPosition].sw}
                                        onCheckedChange={(checked) =>
                                          updateInputEffect(position as EffectPosition, {
                                            sw: checked,
                                          })
                                        }
                                      />
                                      <span className="ml-2">
                                        {inputEffects[position as EffectPosition].sw ? "ON" : "OFF"}
                                      </span>
                                    </div>
                                  </div>

                                  <div>
                                    <Label>エフェクトタイプ</Label>
                                    <Select
                                      value={inputEffects[position as EffectPosition].effectType}
                                      onValueChange={(value) => {
                                        const parameters = getEffectParameters(value);
                                        const defaultParams: Record<string, any> = {};
                                        parameters.forEach((param) => {
                                          defaultParams[param.name] = param.defaultValue;
                                        });

                                        updateInputEffect(position as EffectPosition, {
                                          effectType: value,
                                          parameters: defaultParams,
                                        });
                                      }}
                                    >
                                      <SelectTrigger>
                                        <SelectValue placeholder="Select Effect" />
                                      </SelectTrigger>
                                      <SelectContent>
                                        {getEffectOptions().map((effect) => (
                                          <SelectItem key={effect.value} value={effect.value}>
                                            {effect.label}
                                          </SelectItem>
                                        ))}
                                      </SelectContent>
                                    </Select>
                                  </div>
                                </div>
                              </CollapsibleContent>
                            </Collapsible>
                          </TabsContent>
                        ))}
                      </Tabs>
                    </TabsContent>
                    
                    <TabsContent value="track">
                      <div className="mb-2 text-sm text-muted-foreground">
                        TRACK側のエフェクト設定
                      </div>
                      <Tabs value={currentTab} onValueChange={handleTabChange}>
                        <TabsList className="w-full sm:w-auto">
                          <TabsTrigger value="A">FX A</TabsTrigger>
                          <TabsTrigger value="B">FX B</TabsTrigger>
                          <TabsTrigger value="C">FX C</TabsTrigger>
                          <TabsTrigger value="D">FX D</TabsTrigger>
                        </TabsList>

                        {["A", "B", "C", "D"].map((position) => (
                          <TabsContent key={position} value={position} className="mt-4">
                            <Collapsible className="bg-muted p-4 rounded-md mb-6">
                              <CollapsibleTrigger className="flex items-center justify-between w-full group">
                                <h4 className="text-md font-medium">Effect Control (TRACK)</h4>
                                <ChevronDown className="h-6 w-6 transition-transform duration-200 text-primary group-data-[state=open]:rotate-180" />
                              </CollapsibleTrigger>
                              <CollapsibleContent className="mt-4">
                                <div className="grid grid-cols-1 sm:grid-cols-3 gap-6">
                                  <div>
                                    <Label className="mb-2">SW</Label>
                                    <div className="flex items-center">
                                      <Switch
                                        checked={trackEffects[position as EffectPosition].sw}
                                        onCheckedChange={(checked) =>
                                          updateTrackEffect(position as EffectPosition, {
                                            sw: checked,
                                          })
                                        }
                                      />
                                      <span className="ml-2">
                                        {trackEffects[position as EffectPosition].sw ? "ON" : "OFF"}
                                      </span>
                                    </div>
                                  </div>

                                  <div>
                                    <Label>エフェクトタイプ</Label>
                                    <Select
                                      value={trackEffects[position as EffectPosition].effectType}
                                      onValueChange={(value) => {
                                        const parameters = getEffectParameters(value);
                                        const defaultParams: Record<string, any> = {};
                                        parameters.forEach((param) => {
                                          defaultParams[param.name] = param.defaultValue;
                                        });

                                        updateTrackEffect(position as EffectPosition, {
                                          effectType: value,
                                          parameters: defaultParams,
                                        });
                                      }}
                                    >
                                      <SelectTrigger>
                                        <SelectValue placeholder="Select Effect" />
                                      </SelectTrigger>
                                      <SelectContent>
                                        {getEffectOptions().map((effect) => (
                                          <SelectItem key={effect.value} value={effect.value}>
                                            {effect.label}
                                          </SelectItem>
                                        ))}
                                      </SelectContent>
                                    </Select>
                                  </div>
                                </div>
                              </CollapsibleContent>
                            </Collapsible>
                          </TabsContent>
                        ))}
                      </Tabs>
                    </TabsContent>
                  </Tabs>
                </div>
              ) : (
                <div>
                  <Tabs value={currentTab} onValueChange={handleTabChange}>
                    <TabsList className="w-full sm:w-auto">
                      <TabsTrigger value="A">FX A</TabsTrigger>
                      <TabsTrigger value="B">FX B</TabsTrigger>
                      <TabsTrigger value="C">FX C</TabsTrigger>
                      <TabsTrigger value="D">FX D</TabsTrigger>
                    </TabsList>

                    {["A", "B", "C", "D"].map((position) => (
                      <TabsContent key={position} value={position} className="mt-4">
                        {/* Effect Control Panel */}
                        <Collapsible className="bg-muted p-4 rounded-md mb-6">
                          <CollapsibleTrigger className="flex items-center justify-between w-full group">
                            <h4 className="text-md font-medium">Effect Control</h4>
                            <ChevronDown className="h-6 w-6 transition-transform duration-200 text-primary group-data-[state=open]:rotate-180" />
                          </CollapsibleTrigger>
                          <CollapsibleContent className="mt-4">
                            <div className="grid grid-cols-1 sm:grid-cols-3 gap-6">
                              <div>
                                <Label className="mb-2">SW</Label>
                                <div className="flex items-center">
                                  <Switch
                                    checked={effects[position as EffectPosition].sw}
                                    onCheckedChange={(checked) =>
                                      updateEffect(position as EffectPosition, {
                                        sw: checked,
                                      })
                                    }
                                  />
                                  <span className="ml-2 text-sm text-muted-foreground">
                                    {effects[position as EffectPosition].sw
                                      ? "ON"
                                      : "OFF"}
                                  </span>
                                </div>
                              </div>

                              <div>
                                <Label className="mb-2">SW MODE</Label>
                                <div className="flex space-x-4">
                                  <RadioGroup
                                    value={
                                      effects[position as EffectPosition].swMode
                                    }
                                    onValueChange={(value) =>
                                      updateEffect(position as EffectPosition, {
                                        swMode: value as SwitchMode,
                                      })
                                    }
                                    className="flex space-x-4"
                                  >
                                    <div className="flex items-center space-x-2">
                                      <RadioGroupItem
                                        value="TOGGLE"
                                        id={`toggle-${position}`}
                                      />
                                      <Label htmlFor={`toggle-${position}`}>
                                        TOGGLE
                                      </Label>
                                    </div>
                                    <div className="flex items-center space-x-2">
                                      <RadioGroupItem
                                        value="MOMENT"
                                        id={`moment-${position}`}
                                      />
                                      <Label htmlFor={`moment-${position}`}>
                                        MOMENT
                                      </Label>
                                    </div>
                                  </RadioGroup>
                                </div>
                              </div>
                            </div>
                          </CollapsibleContent>
                        </Collapsible>

                        {/* Effect Selection */}
                        <div className="bg-muted p-4 rounded-md mb-6">
                          <Label>エフェクトタイプ</Label>
                          <div className="mt-2">
                            <Select
                              value={effects[position as EffectPosition].effectType}
                              onValueChange={(value) => handleEffectTypeChange(value)}
                            >
                              <SelectTrigger>
                                <SelectValue placeholder="エフェクトを選択" />
                              </SelectTrigger>
                              <SelectContent>
                                {getEffectOptions().map((effect) => (
                                  <SelectItem key={effect.value} value={effect.value}>
                                    {effect.label}
                                  </SelectItem>
                                ))}
                              </SelectContent>
                            </Select>
                          </div>
                        </div>
                      </TabsContent>
                    ))}
                  </Tabs>
                </div>
              )}
            </div>

            <div className="flex justify-end mt-8 gap-4">
              <Button
                type="button"
                variant="outline"
                onClick={() => navigate("/")}
              >
                キャンセル
              </Button>
              <Button
                type="submit"
                disabled={!presetName.trim() || createPresetMutation.isPending}
              >
                {createPresetMutation.isPending
                  ? "保存中..."
                  : "プリセットを保存"}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}